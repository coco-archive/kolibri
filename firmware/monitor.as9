***************************************************
* set the trap vector at address $fff0 to TRAPMON *
*                                                 *
* DIV0  FDB   TRAPMON                             *
*                                                 *
* This vector is used for division by zero        *
* or in the case of an illegal instruction (6309) *
* So the easiest way to call the monitor is an    *
* illegal instruction, e.g. $15                   *
***************************************************


****************************************
* register position on stack after IRQ *
****************************************

*********
* Stack *
*-------*
* c: PC *
* b:    *
* a: U  *
* 9:    *
* 8: Y  *
* 7:    *
* 6: X  *
* 5: DP *
* 4: F  *
* 3: E  *
* 2: B  *
* 1: A  *
* 0: CC *
*********

*******
TRAPMON
*******

         ANDCC   #%1010 1111   ; enable FIRQ & IRQ
         LDA     #BIOS_DP      ; BIOS direct page
         TFR     A,DP          ; set DP
         SETDP   BIOS_DP       ; inform assembler
         JMP     Monitor

*****************************************
* Machine Language Monitor for 6309 CPU *
*****************************************

Msg_Mon   FCB   "  PC  DP CC  A B  E F    X    Y    U    S    V"
          FCB   " EFHINZVC\r\n;\0"

************
Mon_Commands
************

          FCB   ':',Mon_Modify_Memory
          FCB   ';',Mon_Modify_Register
          FCB   'G',Mon_Go
          FCB   'M',Mon_Show_Memory
          FCB   'R',Mon_Show_Register
          FCB   'X',Mon_Exit
          FCB    0


******
Mon_Go
******

          LDX   #BUF_TXT+2
          LDW   MON_PC        ; preset
          JSR   Mon_Get_Word
          LDS   MON_S         ; S
          STW   10+2,S    ; PC
          LDA   MON_CC
          STA   ,S            ; CC
          LDQ   MON_A         ; A,B,E,F
          STQ   1,S           ; D
          LDA   MON_DP
          STA   3+2,S     ; DP
          LDQ   MON_X
          STQ   4+2,S     ; X,Y
          LDD   MON_U
          STD   8+2,S     ; U
          LDD   MON_V         ; V
          TFR   D,V
          RTI

*******
Monitor
*******

          LDD   10+2,S    ; PC
          STD   MON_PC
          LDD   1,S           ; D
          STQ   MON_A         ; A,B,E,F
          LDQ   4+2,S     ; X,Y
          STQ   MON_X
          LDD   8+2,S     ; U
          STD   MON_U
          STS   MON_S         ; S
          TFR   V,D
          STD   MON_V
          LDA   3+2,S     ; DP
          LDB   ,S            ; CC
          STD   MON_DP
          JSR   Mon_Show_Register

*********
Main_Loop
*********

          PSHS  DP
          TFR   B,DP          ; BASIC DP
          JSR   Edit_Get_Line
          JSR   Mon_CRLF
          PULS  DP

          LDX   #Mon_Commands
          LDA   BUF_TXT+1     ; command
          CMPA  #'a'
          BLO   Moni_20
          ANDA  #%1101 1111   ; force upper case

Moni_20   LDB   ,X+           ; command char
          BEQ   Moni_30       ; not in list
          LDU   ,X++          ; command subroutine
          CMPR  A,B
          BNE   Moni_20       ; next
          LDX   #BUF_TXT+2
          JSR   ,U
          BRA   Main_Loop

Moni_30   JSR   Mon_CRLF
          LDA   #'?'
          CALL  PUTC
          LDA   #BS
          CALL  PUTC
          BRA   Main_Loop


***************
Mon_Show_Memory
***************

***************************************
* Dump a memory range to screen       *
* Read two hex words for start and    *
* stop :XXXX WWWW                     *
* ----------------------------------- *
* Input : X = pointer to input buffer *
*         MON_MEM = default start     *
* Output: X = advanced                *
*         MON_MEM = end address + 1   *
*         D,W modified                *
***************************************

          LDW   MON_MEM       ; preset
          JSR   Mon_Get_Word
          PSHSW               ; push start
          ADDW  #127          ; preset
          JSR   Mon_Get_Word
          PULS  X             ; X = start address
          TFR   W,Y           ; Y = last  address
MoSM_10   JSR   Mon_Dump_Row
                              ; TODO: check STOP key
          CMPR  X,Y
          BHS   MoSM_10
MoSM_20   STX   MON_MEM       ; remember last used
          RTS

*****************
Mon_Modify_Memory
*****************

          BSR   Mon_Get_Word
          TFR   W,Y           ; Y = start address
          LDB   #8
MoMM_10   BSR   Mon_Get_Byte
          STA   ,Y+
          DECB
          BNE   MoMM_10
          RTS

*******************
Mon_Modify_Register
*******************

          LDY   #MONBUF
MoMR_10   BSR   Mon_Get_Byte
          STA   ,Y+
          CMPY  #MONBUF+18
          BLO   MoMR_10
          RTS

*****************
Mon_Show_Register
*****************

          LDX   #Msg_Mon
          JSR   [VECTBL+PUTS*2]

          LDX   #MONBUF
          LDD   ,X++           ; PC
          JSR   Mon_Show_Word
          LDA   ,X+            ; DP
          BSR   Mon_Show_Blank_Byte
          LDA   ,X+            ; CC
          BSR   Mon_Show_Blank_Byte
MoSR_10   JSR   Mon_Blank
          LDD   ,X++           ; D W X Y U S V
          JSR   Mon_Show_Word
          CMPX  #MONBUF+18
          BLO   MoSR_10
          JSR   Mon_Blank
          LDA   MON_CC
          STA   MON_TMP
          LDB   #8
MoSR_20   LDA   #'0'
          ROL   MON_TMP
          ADCA  #0
          JSR   [VECTBL+PUTC*2]
          DECB
          BNE   MoSR_20
          JMP   Mon_CRLF

*******************
Mon_Show_Blank_Byte
*******************

          PSHS  A
          JSR   Mon_Blank
          PULS  A
          JMP   Mon_Show_Byte

********
Mon_Exit
********

          JMP   DIE

************
Mon_Get_Word
************

*****************************************
* Convert four hex digits to word value *
* skipping an optional leading blank    *
* ------------------------------------- *
* Input : X = pointer to input buffer   *
*       : W = default result            *
* Output: W = word value                *
*       : X = advanced after hex word   *
*****************************************

          LDA   ,X            ; next char
          CMPA  #' '          ; leading blank ?
          BLO   MoGW_Ret      ; -> error
          BEQ   MoGW_10       ; -> skip
          CMPA  #','          ; comma separator ?
          BEQ   MoGW_10       ; -> yes
          CMPA  #'-'          ; dash separator ?
          BNE   MoGW_20       ; -> no
MoGW_10   LEAX  1,X           ; skip 1 char
MoGW_20   BSR   Mon_Get_Byte  ; 2 hex to byte
          TFR   A,E           ; high byte
          BSR   Mon_Get_Byte  ; 2 hex to byte
          TFR   A,F           ; low   byte
MoGW_Ret  RTS

************
Mon_Get_Byte
************

****************************************
* Convert two hex digits to byte value *
* skipping an optional leading blank   *
* ------------------------------------ *
* Input :  X = pointer to input buffer *
* Output:  A = byte value              *
*          X = advanced after hex byte *
****************************************

          PSHS  B              ; save B
          LDB   ,X             ; next char
          CMPB  #' '           ; leading blank ?
          BNE   MoGB_10        ; -> no
          LEAX  1,X            ; skip blank
MoGB_10   BSR   Mon_Get_Nibble ; get high nibble
          TFR   B,A            ; store in A
          LSLA                 ; shift to high
          LSLA
          LSLA
          LSLA
          BSR   Mon_Get_Nibble ; get low nibble
          ORR   B,A            ; combine nibbles -> A
          PULS  PC,B

**************
Mon_Get_Nibble
**************

*****************************************
* Get a hex digit from buffer pointer X *
* convert it to binary  and return in A *
* ------------------------------------- *
* Input : X = pointer to next hex digit *
* Output: B = nibble value              *
*         X++                           *
*****************************************

          LDB   ,X+           ; get hex digit
          CMPB  #'9'+1        ; numeric ?
          BLO   MGB_10        ; -> yes
          SUBB  #7            ; assume A -> F
MGB_10    ANDB  #15           ; to binary
          RTS

************
Mon_Dump_Row
************

*****************************************************
* Print a row of 16 bytes as hexdump and ASCII dump *
* ------------------------------------------------- *
* Input : X = start address                         *
* Output: X += 16                                   *
*         A,B,E modified                            *
*****************************************************

          LDA   #':'          ; modify memory symbol
          CALL  PUTC
          TFR   X,D
          BSR   Mon_Show_Word ; print start address
          CLRE                ; index
MDR_10    BSR   Mon_Blank
          LDA   E,X           ; next byte
          BSR   Mon_Show_Byte
          CMPE  #7
          BNE   MDR_20
          BSR   Mon_Blank     ; insert blank after 8
MDR_20    INCE
          CMPE  #16
          BNE   MDR_10
          BSR   Mon_Blank     ; E = 16
MDR_30    LDA   ,X+
          BMI   MDR_40
          CMPA  #' '          ; printable ?
          BHS   MDR_50
MDR_40    LDA   #'.'
MDR_50    CALL  PUTC
          CMPE  #9
          BNE   MDR_60
          BSR   Mon_Blank
MDR_60    DECE
          BNE   MDR_30        ; fall through at end
          SIZE

********
Mon_CRLF
********

          LDA   #CR
          CALL  PUTC
          LDA   #LF
          CALL  PUTC
          RTS

*********
Mon_Blank
*********

          LDA   #' '
          CALL  PUTC
          RTS

*************
Mon_Show_Word
*************

******************************
* Print D as four hex digits *
* -------------------------- *
* Input : D = value          *
* Output: A = low byte hex   *
*         B = #PUTC          *
******************************

          PSHS  B              ; push  low byte
          BSR   Mon_Show_Byte  ; print high byte
          PULS  A              ; pull  low  byte
                               ; fall  through

*************
Mon_Show_Byte
*************

*****************************
* Print A as two hex digits *
* ------------------------- *
* Input : A = value         *
* Output: A = low byte hex  *
*         B = #PUTC         *
*****************************

          PSHS  A
          LSRA
          LSRA
          LSRA
          LSRA
          BSR   Mon_Nib_Hex
          PULS  A             ; fall through
          SIZE

***********
Mon_Nib_Hex
***********

************************************
* Print lower nibble of value in A *
* -------------------------------- *
* Input : A = binary number        *
* Output: A = hex digit (0 - F)    *
*         B = #PUTC                *
************************************

          ANDA  #15
          CMPA  #10
          BLO   MoNH_10
          ADDA  #7
MoNH_10   ADDA  #'0'
          CALL  PUTC
          RTS

