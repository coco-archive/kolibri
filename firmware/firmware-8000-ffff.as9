        STORE   $8000,$8000,"firmware-8000-ffff.bin"
        ORG     $8000
        INCLUDE "kolibri-definitions.as9"
        INCLUDE "macros.as9"

VDPFONTDATA = $E000             ; fontata start
VDPFONTSIZE = $0800             ; fontdata size

        LOAD    VDPFONTDATA,"fonts/font-6x8-437-euro.fon"


********
Do_Reset                        ; cold start machine
********

        ORCC    #IRQFLAG|FIRQFLAG ; disable interrupts
        SETDP   BIOS_DP
        LDA     #BIOS_DP
        TFR     A,DP            ; Set direct page register
        LDS     #MACHINESTACK
        LDU     #USERSTACK
        LDMD    #$01            ; Switch to 6309 native mode,
                                ; FIRQ-handling as on the 6809
        CLR     BIOS_EMU_Flag
        LDA     #$55
        STA     $FEFF
        LDA     $FEFF
        CMPA    #$aa
        BNE     Greet
        INC     BIOS_EMU_Flag   ; don't use VDP

*****
Greet
*****

; No high level code here, the output shall work even with broken RAM chip
; Write greeter to USB virtual COM port
        LDX     #FT245PR
GRTLP   LDA     ,X+
        BEQ     Greet_20
; TODO: check if chip is ready
        STA     IO_FT245R
        BRA     GRTLP

FT245PR FCC "\r\n\r\n"
BOOTPRM FCC "kolibri.computer BIOS 2020-03-06\n\0"
Greet_20

; Write greeter to V9958 screen
        JSR     VDP_Init
        JSR     VDP_On
        LDA     #$01            ; blue
        JSR     VDP_BGColor1
        LDA     #$0F            ; white
        JSR     VDP_Color1
        LDA     #$01            ; blue
        JSR     VDP_BGColor2
        LDA     #$0C            ; lightred
        JSR     VDP_Color2

        jsr     VDP_PutColor2
        LDX     #BOOTPRM
GRTLP2  LDA     ,X+
        BEQ     Greet_80
        PSHS    X
        JSR     VDP_Out
        PULS    X
        BRA     GRTLP2
Greet_80


; Further machine initialization
        JSR     Init_Vectors

*****************************
* Little emulator test/demo *
*****************************

        LDX     #QUESTION
        CALL    PUTS
        JSR     Edit_Get_Line
        JSR     Mon_CRLF

        LDX     #HELLO
        CALL    PUTS
        LDX     #BUF_TXT+1
        CALL    PUTS
        JSR     Mon_CRLF

        ILLOP                   ; Call monitor


QUESTION FCC    "What's your name? \0"
HELLO   FCC     "Hi \0"


DIE

    IF 1                        ; some last pre-mortal actions
        clra
LOOPASC pshs A
        jsr VDP_PutChar
        puls A
        inca
        bra LOOPASC
   ENDIF

        SYNC                    ; stop execution
        BRA     DIE             ; just in case


************
Init_Vectors
************

        LDX     #VECT_ROMTBL
        LDY     #VECTBL
        LDW     #VECT_ROMTBL_END - VECT_ROMTBL
        TFM     X+,Y+
        RTS


**********************************
* Include library of subroutines *
**********************************

        INCLUDE "vdp.as9"       ; VDP Definitions + Subroutines
        INCLUDE "monitor.as9"   ; Machine Language Monitor
        INCLUDE "edit.as9"      ; Screen editor


********
To_Upper
********

*****************************************************
* Convert character to uppercase                    *
* ------------------------------------------------- *
* Input : A = any value                             *
* Output: A = upper case character if A was a lower *
*             case character, unchanged if not      *
*****************************************************

        CMPA    #'a'
        BLO     TU_80
        CMPA    #'z'
        BHI     TU_80
        EORA    #$20
TU_80   RTS

*******
VDP_Out
*******

*************************************************
* Output a byte to the VDP or call VDP function *
* --------------------------------------------- *
* Input : A = character or control code (00-1F) *
*************************************************

        CMPA    #DEL          ; delete char right
        BNE     VO_10
        CLRA                  ; map DEL to NULL
VO_10   CMPA    #' '
        BLO     VO_20         ; -> control code
        JMP     VDP_PutChar   ; printable

VO_20   ASLA
        LDX     #VDP_TABLE
        JMP     [A,X]         ; VDP control

*******
USB_Out
*******

******************************************
* Output a byte over the USB serial port *
* -------------------------------------- *
* Input : A = byte to be written         *
******************************************

; TODO: check if chip is ready
        STA     IO_FT245R
        RTS


******
USB_In
******

*****************************************
* Read a byte from the USB serial port  *
* ------------------------------------- *
* Output: A:  read character            *
*         B:  zero if no data available *
*****************************************

        LDB     #$01            ; data available flag
        TST     BIOS_EMU_Flag
        BNE     UI_70           ; -> emu active
        LDA     IO_INPORT       ; data available?
        BITA    #IO_INRXF
        BEQ     UI_70           ; branch if data available
        CLRD                    ; return '\0' and no data available flag
        BRA     UI_80
UI_70   LDA     IO_FT245R       ; read character from USB serial port
UI_80   STA     SOFF_A,S        ; return character in stacked A
        STB     SOFF_B,S        ; return flag in stacked B
        RTS


*******
Do_PUTS
*******

******************************************
* Write zero terminated string to stdout *
* -------------------------------------- *
* Input : X = start address of string    *
* Output: A = \0                         *
******************************************

        LDA     ,X+
        BEQ     PUTS_80
        JSR     [VECTBL+PUTC*2]
        BRA     Do_PUTS
PUTS_80 RTS


****************************************
* Default values for vectored routines *
****************************************

VECT_ROMTBL
        FDB     USB_Out         ; STDOUT
        FDB     USB_In          ; STDIN
        FDB     Do_PUTS
VECT_ROMTBL_END

        IF ((VECT_ROMTBL_END - VECT_ROMTBL) >> 1) > 255
                ERROR DO_SWI can't handle more than 255 entries
        ENDIF

*********************
* Interrupt vectors *
*********************

***********
* Stack   *
*---------*
* c: PC   *
* b:      *
* a: U    *
* 9:      *
* 8: Y    *
* 7:      *
* 6: X    *
* 5: DP   *
* 4: F    *
* 3: E    *
* 2: B    *
* 1: A    *
* 0: CC   *
***********

******
DO_SWI
******

************************************
* Entry for software interrupt SWI *
* -------------------------------- *
* Input: B = function number       *
************************************

        CMPB    #(VECT_ROMTBL_END - VECT_ROMTBL) >> 1
        BHS     Do_Bad_SWI      ; -> illegal number
        ANDCC   #%1010 1111     ; enable FIRQ & IRQ
        LDA     #BIOS_DP        ; BIOS direct page
        TFR     A,DP            ; set DP
        SETDP   BIOS_DP         ; inform assembler
        LDX     #VECTBL         ; switch table
        ABX
        ABX                     ; X += 2 * BL
        LDD     ,X              ; D = function address [X+B+B]
        STD     BIOS_ADR        ; store function address
        LDD     1,S             ; restore D from stack
        LDX     6,S             ; restore X from stack
        JSR     [BIOS_ADR]      ; call BIOS subroutine
        RTI                     ; return from interrupt

Do_Bad_SWI
        LDX     #Bad_SWI
        JSR     Do_PUTS
        RTI

Bad_SWI FCC     "ILLEGAL SWI\n\0"


DO_SWI2
DO_SWI3
DO_IRQ
DO_FIRQ
DO_NMI  JMP     TRAPMON

        ORG     $FFF0

HW_EXCEPTION FDB TRAPMON
HW_SWI3      FDB DO_SWI3
HW_SWI2      FDB DO_SWI2
HW_FIRQ      FDB DO_FIRQ
HW_IRQ       FDB DO_IRQ
HW_SWI       FDB DO_SWI
HW_NMI       FDB DO_NMI
HW_RESET     FDB Do_Reset

