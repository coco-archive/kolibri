; ***** VDP-Definitions

PAL = 1			; PAL=1, NTSC=0	selects V9938/58 PAL RGB-output

PATTERNTABLE	= $1000		; font memory in VRAM
COLORTABLE	= $0A00		; color/attribute-table in VRAM
SCREENTABLE	= $0000		; screen memory in VRAM

VDPREG1		= $10		; VDP reg 1 value (mode bits M1+M2, screen disabled)
VDPREG9		= $80 | PAL*2	; VDP reg 9 value ($80 = NTSC, $82 = PAL / 212 lines)
VDPREG18		= $0d		; VDP reg 18 value (V/H screen adjust, $0d = Sony PVM 9")

VDPCOLOR1	= 15		; start color values
VDPCOLOR2	= 12
VDPBGCOLOR1	= 1
VDPBGCOLOR2	= 1

COLUMNS		= 80		; screen columns
ROWS		= 26		; used lines

**************************************************************************
; VDP-Macros

VDPWAITC		MACRO ARG	; wait ARG cycles
		FILL ARG ($12)		; each $12=nop needs 1/3 us @ 3MHz 6309/native mode
		ENDM

VDPSETREG  	MACRO ARG	; *** set VDP Register ARG to A
		pshs cc			; safe flags
		orcc  #IRQFLAG|FIRQFLAG	; disable interrupts
		sta VDPCONTROL		; first writes data in A to control port #1
		nop			; adds 2 nops to reach 2us pause
		nop
		lda # ARG | $80		; writes register no. with bit#7 = 1 to Port #1
		sta VDPCONTROL
		puls cc			; restore flags
		ENDM

VDPWRITEADDRESS 	MACRO		; *** set VDP write vram address-pointer to D
		pshs cc			; safe flags
		orcc #IRQFLAG|FIRQFLAG	; disable interrupts
		stb VDPCONTROL		; write address low-byte
		nop			; adds 2 nops to reach 2us pause  
		nop
		ora # $40		; bit#6 = 1 write
	         sta VDPCONTROL		; write address high-byte
		puls cc			; restore flags
	         ENDM

; ***** VDP-Subroutines

VDP_Wait16c				; *** wait 16 cycles
		FILL 6 ($12)		; total with jsr/rts -> 16 cycles
		rts

VDP_Init				; *** initialize VDP ***
		clra
		VDPSETREG 17		; write VDP regs fast indirect
		ldx #VDPINITDATA
VDPINITREGS	lda ,x+
		jsr VDP_Wait16c		; add 6 us to reach 8 us
		sta VDPINDIRECT
		cmpx #VDPINITDATAEND
		bne VDPINITREGS

		lda # VDPREG18
		VDPSETREG 18		; set register 18 V/H display adjust L 7-1,0,f-8 R
					; * clear 16kB VRAM
		jsr VDP_Wait16c 
		clrd
		VDPWRITEADDRESS		; set VRAM write address to D = $0000, Bank Reg already $00
		ldw #$4000		; set counter W to $4000
CLEARVRAM	jsr VDP_Wait16c			; vdp pause between VRAM write 8 us 
		stb VDPRAM		; B = VRAM init value = $00
		decw
		bne CLEARVRAM
					; * copy font to pattern generator table
		jsr VDP_Wait16c
		ldd #PATTERNTABLE
		VDPWRITEADDRESS		; set VRAM write address to D = Patterntable
		ldx #VDPFONTDATA
VDPLOADFONT	lda ,x+
		jsr VDP_Wait16c
		sta VDPRAM
		cmpx #VDPFONTDATA+VDPFONTSIZE
		bne VDPLOADFONT
					; * load color palette
		jsr VDP_Wait16c
		clra
		VDPSETREG 16		 
		ldx #VDPPALETTEDATA
VDPINITPALETTE	lda ,x+			; load palette-color to write
		jsr VDP_Wait16c
		sta VDPPALETTE		; write to palette register
		cmpx #VDPPALETTEDATAEND
		bne VDPINITPALETTE

		jsr VDP_Wait16c
		ldd #SCREENTABLE
		VDPWRITEADDRESS		; set VRAM write address to D = Screentable
		ldw #(ROWS+1)*COLUMNS
		lda #' '			; fill with SPACE
VDPCLEARSCREEN	jsr VDP_Wait16c
		VDPWAITC 2
		sta VDPRAM
		decw
		bne VDPCLEARSCREEN

		lda #0			; initialize zeropage variables
		sta BIOS_RowTop
		lda #ROWS-1
		sta BIOS_RowBottom
		lda #COLUMNS
		sta BIOS_Columns
		lda #VDPCOLOR1
		sta BIOS_Color1
		lda #VDPCOLOR2
		sta BIOS_Color2
		lda #VDPBGCOLOR1
		sta BIOS_BGColor1
		lda #VDPBGCOLOR1
		sta BIOS_BGColor1
		rts

VDP_On				; *** enable screen ***
		lda #VDPREG1 | $40	; set mode reg 1 (M1+M2), bit#6 = 1 enables screen
		VDPSETREG 1
		rts

VDP_Off				; *** disable screen ***
		lda #VDPREG1 & $bf	; set mode reg 1 (M1+M2), bit#6 = 1 enables screen
		VDPSETREG 1
		rts

VDP_ClearWindow
		lda BIOS_RowTop		; load windows top row
		ldb BIOS_Columns		; load columns
		mul			; calc screen position
		addd #SCREENTABLE		; add VRAM position
		VDPWRITEADDRESS		; set VRAM write address to D = Screentable
		lda BIOS_RowBottom	; load window bottom row 
		adda #1			; add one line to bottom
		suba BIOS_RowTop		; calc lines to clear (Carry flag already 0 from adda)
		ldb BIOS_Columns
		mul			; calc bytes to clear
		lde #' '			; fill with SPACE
VDPCLEARWINDOW	jsr VDP_Wait16c
		VDPWAITC 1
		ste VDPRAM
		decd
		bne VDPCLEARWINDOW
		sta BIOS_CursorX		; set cursor to 0,0 (A is already 0 from decd)
		sta BIOS_CursorY
		rts

VDP_SetColor			; *** sets color register 7 + 12 from color variables
		lda BIOS_Color1		; load color 1 variable
		asla			; shift to high nibble
		asla
		asla
		asla
		ora BIOS_BGColor1		; add bg color variable
		VDPSETREG 7		; set color register
		lda BIOS_Color2
		asla
		asla
		asla
		asla
		ora BIOS_BGColor2
		jsr VDP_Wait16c
		VDPSETREG 12
		rts

VDP_ReadStatus			; *** read status register in A - return status in A
		lda #1
		VDPSETREG 15		; reg 15 = 1 initiates read status-reg 1
		jsr VDP_Wait16c		; wait 8 us total for DVP
		VDPWAITC 2
		lda VDPSTATUS		; read status
		rts

**************************************************************************
; vdp-tables
VDPINITDATA			; ***** VDP init data table *****
	FCB $04,VDPREG1,$03,$2f,$02,$3f,$03,VDPCOLOR1*16+VDPBGCOLOR1
	FCB $08,VDPREG9,$00,$00,VDPCOLOR2*16+VDPBGCOLOR2,$f0,$00
	; reg  0: $04 mode control 1: text mode 2 (bit#1-3 = M3 - M5)
	; reg  1: $10 mode control 2: bit#1 16x16 sprites, bit#3-4 = M2-M1, #6 =1: display enable)
	; reg  2: $03 name (screen) table base address $0000 ( * $400 + bit#0+1 = 1)
	; reg  3: $2f color table base address $0A00 ( * $40 + bit#0-2 = 1)
	; reg  4: $02 pattern (character) generator table base address $1000 (* $800)
	; reg  5: $3f sprite attribute table base address $1e00 (* $80 - bit#0+1 = 1)
	; reg  6: $03 sprite pattern (data) generator base address = $1800 (* $800)
	; reg  7: $10 text/overscan-backdrop color 
	; reg  8: $08 bit#3 = 1: 64k VRAM chips, bit#1 = 0 sprites disable, bit#5 0=transparent
	; reg  9: $80 bit#1 = NTSC/PAL, #2 = EVEN/ODD, #3 = interlace, #7 = 192/212 lines
	; reg 10: $00 color table base address $0000 bit#0-2 = A14-A16
	; reg 11: $00 sprite attribute table base address bit#0-1 = A15-A16
	; reg 12: $20 text/background blink color
	; reg 13: $f0 blink periods ON/OFF - f0 = blinking off
	; reg 14: $00 VRAM write addresss bit#0-2 = A14-A16
	; reg 16: $00 color palette pointer to color 0
VDPINITDATAEND

VDPPALETTEDATA	; ***** Color Palette - 16 colors, 2 byte/color RB, 0G each 3bit -> CGA-colors *****
	FCB $00,$00,$05,$00,$00,$05,$05,$05   ;   0=black     1=blue      2=green       3=cyan
	FCB $50,$00,$55,$00,$50,$03,$55,$05   ;   4=red       5=magenta   6=brown       7=lightgrey
	FCB $33,$03,$37,$03,$33,$07,$37,$07   ;   8=grey      9=lightblue a=lightgreen  b=lightcyan
	FCB $73,$03,$77,$03,$73,$07,$77,$07   ;   c=lightred  d=ltmagenta e=yellow      f=white
VDPPALETTEDATAEND
	FCB 0				; only to get last label !