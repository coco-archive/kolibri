; ***** VDP-Definitions

PAL = 1                         ; PAL=1, NTSC=0   selects V9938/58 PAL RGB-output

PATTERNTABLE    = $1000         ; font memory in VRAM
COLORTABLE      = $0A00         ; color/attribute-table in VRAM
SCREENTABLE     = $0000         ; screen memory in VRAM

VDPREG1         = $10           ; VDP reg 1 value (mode bits M1+M2, screen disabled)
VDPREG9         = $80 | PAL*2   ; VDP reg 9 value ($80 = NTSC, $82 = PAL / 212 lines)
VDPREG18        = $0d           ; VDP reg 18 value (V/H screen adjust, $0d = Sony PVM 9")

VDPCOLOR        = 15            ; start color values
VDPBGCOLOR      = 1

COLUMNS         = 80            ; screen columns
ROWS            = 26            ; used lines

**************************************************************************
; VDP-Macros

VDPWAITC MACRO ARG      ; *** wait ARG cycles
        FILL ARG ($12)          ; each $12=nop needs 1/3 us @ 3MHz 6309/native mode
        ENDM

VDPSETREG MACRO ARG     ; *** set VDP Register ARG to A
        pshs cc                 ; safe flags
        orcc  #IRQFLAG|FIRQFLAG ; disable interrupts
        sta IO_VDPCONTROL       ; first writes data in A to control port #1
        nop                     ; adds 2 nops to reach 2us pause
        nop
        lda # ARG | $80         ; writes register no. with bit#7 = 1 to Port #1
        sta IO_VDPCONTROL
        puls cc                 ; restore flags
        ENDM

VDPWRITEADDRESS MACRO   ; *** set VDP write vram address-pointer to D
        pshs cc                 ; safe flags
        orcc #IRQFLAG|FIRQFLAG  ; disable interrupts
        stb IO_VDPCONTROL       ; write address low-byte
        nop                     ; adds 2 nops to reach 2us pause
        nop
        ora # $40               ; bit#6 = 1 write
        sta IO_VDPCONTROL       ; write address high-byte
        puls cc                 ; restore flags
        ENDM

VDPREADADDRESS MACRO    ; *** set VDP read vram address-pointer to D
        pshs cc                 ; safe flags
        orcc #IRQFLAG|FIRQFLAG  ; disable interrupts
        stb IO_VDPCONTROL       ; read address low-byte
        nop                     ; adds 2 nops to reach 2us pause
        nop
        nop 
        nop
        sta IO_VDPCONTROL       ; read address high-byte
        puls cc                 ; restore flags
        ENDM
        
; ***** VDP-Subroutines

VDP_Wait16c             ; *** wait 16 cycles
        FILL 6 ($12)            ; total with jsr/rts -> 16 cycles
        rts

VDP_Init                ; *** initialize VDP ***
        clra
        VDPSETREG 17            ; write VDP regs fast indirect
        ldx #VDPINITDATA
VDPINIT lda ,x+
        jsr VDP_Wait16c         ; add 6 us to reach 8 us
        sta IO_VDPINDIRECT
        cmpx #VDPINITDATAEND
        bne VDPINIT

        lda # VDPREG18
        VDPSETREG 18            ; set register 18 V/H display adjust L 7-1,0,f-8 R
                                ; * clear 16kB VRAM
        jsr VDP_Wait16c
        clrd
        VDPWRITEADDRESS         ; set VRAM write address to D = $0000, Bank Reg already $00
        ldw #$4000              ; set counter W to $4000
VDPCLRR jsr VDP_Wait16c         ; vdp pause between VRAM write 8 us
        stb IO_VDPRAM           ; B = VRAM init value = $00
        decw
        bne VDPCLRR
                                ; * copy font to pattern generator table
        jsr VDP_Wait16c
        ldd #PATTERNTABLE
        VDPWRITEADDRESS         ; set VRAM write address to D = Patterntable
        ldx #VDPFONTDATA
VDPLFNT lda ,x+
        jsr VDP_Wait16c
        sta IO_VDPRAM
        cmpx #VDPFONTDATA+VDPFONTSIZE
        bne VDPLFNT
                                ; * load color palette
        jsr VDP_Wait16c
        clra
        VDPSETREG 16
        ldx #VDPPALETTEDATA
VDPLPAL lda ,x+                 ; load palette-color to write
        jsr VDP_Wait16c
        sta IO_VDPPALETTE       ; write to palette register
        cmpx #VDPPALETTEDATAEND
        bne VDPLPAL

        jsr VDP_Wait16c
        ldd #SCREENTABLE
        VDPWRITEADDRESS         ; set VRAM write address to D = Screentable
        ldw #(ROWS+1)*COLUMNS
        lda #' '                ; fill with SPACE
VDPCLRS jsr VDP_Wait16c
        VDPWAITC 2
        sta IO_VDPRAM
        decw
        bne VDPCLRS

        lda #0                  ; initialize zeropage variables
        sta BIOS_RowTop
        lda #ROWS-1
        sta BIOS_RowBottom
        lda #COLUMNS
        sta BIOS_Columns
        lda #VDPCOLOR
        sta BIOS_Color
        lda #VDPBGCOLOR
        sta BIOS_BGColor
        rts

VDP_On                          ; *** enable screen ***
        lda #VDPREG1 | $40      ; set mode reg 1 (M1+M2), bit#6 = 1 enables screen
        VDPSETREG 1
        rts

VDP_Off                         ; *** disable screen ***
        lda #VDPREG1 & $bf      ; set mode reg 1 (M1+M2), bit#6 = 1 enables screen
        VDPSETREG 1
        rts

VDP_ClearWindow
        jsr VDP_CursorOff
        lda BIOS_RowTop         ; load windows top row
        ldb BIOS_Columns        ; load columns
        mul                     ; calc screen position
        addd #SCREENTABLE       ; add VRAM position
        VDPWRITEADDRESS         ; set VRAM write address to D = Screentable
        lda BIOS_RowBottom      ; load window bottom row
        adda #1                 ; add one line to bottom
        suba BIOS_RowTop        ; calc lines to clear (Carry flag already 0 from adda)
        ldb BIOS_Columns
        mul                     ; calc bytes to clear
        lde #' '                ; fill with SPACE
VDPCLRW jsr VDP_Wait16c
        VDPWAITC 1
        ste IO_VDPRAM
        decd
        bne VDPCLRW
        sta BIOS_CursorX        ; set cursor to column 0 (A is already 0 from decd)
        lda BIOS_RowTop
        sta BIOS_CursorY        ; set cursor to window top line
        jsr VDP_CursorOn
        rts

VDP_SetBGColor            ; *** set background-color from A to register 7 + revers in 12
        sta BIOS_BGColor
        lda BIOS_Color
        bra VDPSCOL

VDP_SetColor            ; *** set text-color from A to register 7 + revers in 12
        sta BIOS_Color          ; store new textcolor
VDPSCOL lsla                    ; shift to high nibble
        lsla
        lsla
        lsla
        ora BIOS_BGColor        ; add bg color variable
        VDPSETREG 7             ; set color register
        lda BIOS_BGColor
        lsla
        lsla
        lsla
        lsla
        ora BIOS_Color
        jsr VDP_Wait16c
        VDPSETREG 12
        rts

VDP_PutChar             ; *** puts char from A to screen at actual cursor position and moves cursor
        tfr a,e                 ; safe char in E 
        lda BIOS_CursorY        ; load cursor line
        ldb BIOS_Columns        ; load columns
        mul                     ; calc line position
        ldf BIOS_CursorX        ; load Cursor column
        addr f,d                ; calc screen position
        addd #SCREENTABLE       ; add VRAM position
        VDPWRITEADDRESS         ; set VRAM write address to D = Screentable
        jsr VDP_Wait16c
        VDPWAITC 1
        ste IO_VDPRAM
VDP_CursorRight         ; *** Move cursor right
        jsr VDP_CursorOff
        lda BIOS_CursorX
        inca                    ; move right
        cmpa BIOS_Columns       ; end of line ?
        bne VDPCRSR             ; not column end ?
        lda BIOS_CursorY
        cmpa BIOS_RowBottom     ; reached window bottom row ?
        bne VDPCRRS             ; no scroll neccessary
        jsr VDP_ScrollUp
        bra VDPCRRE
VDPCRRS inca 
        sta BIOS_CursorY
VDPCRRE clra
VDPCRSR sta BIOS_CursorX
        jsr VDP_CursorOn
        rts

VDP_CursorLeft          ; *** Move cursor left
        jsr VDP_CursorOff
        lda BIOS_CursorX
        bne VDPCRSL             ; not column 0 ?
        lda BIOS_CursorY
        cmpa BIOS_RowTop        ; reached window top row ?
        beq VDPCRLE
        deca                    ; move one row up
        sta BIOS_CursorY
        lda BIOS_Columns
VDPCRSL deca                    ; move left
        sta BIOS_CursorX
VDPCRLE jsr VDP_CursorOn
        rts

VDP_CursorDown          ; *** Move cursor down
        lda BIOS_CursorY
        cmpa BIOS_RowBottom     ; reached window bottom row ?
        bne VDPCRSD
        jsr VDP_ScrollUp        ; scroll up
        rts
VDPCRSD jsr VDP_CursorOff
        inca
        sta BIOS_CursorY        ; move down
        jsr VDP_CursorOn
        rts

VDP_CursorUp            ; *** Move cursor up
        lda BIOS_CursorY
        cmpa BIOS_RowTop        ; reached window top row ?
        beq VDPCRSU
        jsr VDP_CursorOff
        deca
        sta BIOS_CursorY        ; move up
        jsr VDP_CursorOn
VDPCRSU rts

VDP_ScrollUp            ; *** scroll screen up
        lde BIOS_RowTop
        cmpe BIOS_RowBottom
        beq VDPSCRN
        tfr e,a
        ldb BIOS_Columns
        mul
        addd #SCREENTABLE       ; calc target line screen address
        tfr d,x                 ; move target address to X
        ldf BIOS_Columns
VDPSCRL addr f,d                ; calc source line address
        VDPREADADDRESS
        ldy #0
        ldb BIOS_Columns
VDPSCRS jsr VDP_Wait16c
        lda IO_VDPRAM
        sta LINEBUF,y+
        decb
        bne VDPSCRS             ; end of line? 
        tfr x,d                 ; move target address to D    
        VDPWRITEADDRESS
        ldy #0
        ldb BIOS_Columns
VDPSCRT jsr VDP_Wait16c
        lda LINEBUF,y+
        sta IO_VDPRAM
        decb
        bne VDPSCRT
        ince                    ; next row
        cmpe BIOS_RowBottom
        beq VDPSCRN             ; last row - finished scrolling
        addr f,x                ; add columns to calc next target line
        tfr x,d                 ; copy target address to D
        bra VDPSCRL
VDPSCRN lda BIOS_RowBottom      ; bottom row l√∂schen
        ldb BIOS_Columns
        mul
        addd #SCREENTABLE       ; calc screen address
        VDPWRITEADDRESS
        lda BIOS_Columns
        ldb #' '                ; clear line with SPACE
VDPSCRC jsr VDP_Wait16c
        VDPWAITC 2
        stb IO_VDPRAM
        deca
        bne VDPSCRC
        rts 

VDP_CursorOff            ; *** set cursor attribute byte in color table
        lda BIOS_CursorY        ; load cursor line
        ldb BIOS_Columns        ; load columns
        mul                     ; calc line position
        ldf BIOS_CursorX        ; load Cursor column
        lsrd                    ; divide by 8 to calc color/attribute-table position
        lsrd
        lsrd
        addd #COLORTABLE        ; add VRAM position
        VDPWRITEADDRESS         ; set VRAM write address to D = Colortable
        jsr VDP_Wait16c
        clra
        sta IO_VDPRAM
        rts

VDP_CursorOn            ; *** set cursor attribute bit in color table
        lda BIOS_CursorY        ; load cursor line
        ldb BIOS_Columns        ; load columns
        mul                     ; calc line position
        ldf BIOS_CursorX        ; load Cursor column
        addr f,d                ; calc screen position
        tfr a,e                 ; safe low byte of screen position in E
        lsrd                    ; divide by 8 to calc color/attribute-table position
        lsrd
        lsrd
        addd #COLORTABLE        ; add VRAM position
        VDPWRITEADDRESS         ; set VRAM write address to D = Colortable
        tfr e,a                 ; restore low byte
        anda #$07               ; isolate byte position
        clrb
        tfr d,x
        lda REVERSETABLE,x      ; load bit for screen position
        VDPWAITC 8
        sta IO_VDPRAM
        rts
REVERSETABLE    FCB $80,$40,$20,$10,$08,$04,$02,$01

VDP_Backspace              ; *** backspace
        jsr VDP_CursorLeft
        lda BIOS_CursorY
        cmpa BIOS_RowTop        ; check if window top row    
        bne VDP_Delete
        lda BIOS_CursorX        ; check if first char in window
        bne VDP_Delete
        rts                     ; no delete possible in uper left corner !

VDP_Delete              ; *** delete character
        lda BIOS_CursorY        ; load cursor line
        ldb BIOS_Columns        ; load columns
        mul                     ; calc line position
        ldf BIOS_CursorX        ; load Cursor column
        addr f,d                ; calc screen position
        addd #SCREENTABLE       ; add VRAM position
        tfr d,x                 ; safe write address in X
        ldb BIOS_CursorX        ; Load Cursor column
        incb                    ; add 1 because last col is 79 and columns is 80 !
        cmpb BIOS_Columns       ; check if last char in line
        beq VDPDELN             ; skip srolling
        incd                    ; calc read address
        VDPREADADDRESS          ; set VRAM write address to D = Screentable
        ldy #0
VDPDELR jsr VDP_Wait16c
        lda IO_VDPRAM           ; load char
        sta LINEBUF,y+          ; write char to buffer
        incb
        cmpb BIOS_Columns       ; check reached end of line ?
        bne VDPDELR             ; read next char
        tfr x,d                 ; restore write address
        VDPWRITEADDRESS
        ldb BIOS_CursorX        ; Load Cursor column
        incb                    ; add 1 because last col is 79 and columns is 80 !
        ldy #0
VDPDELW jsr VDP_Wait16c
        lda LINEBUF,y+          ; read char from buffer
        sta IO_VDPRAM           ; write char
        incb
        cmpb BIOS_Columns       ; check reached end of chars in buffer ?
        bne VDPDELW             ; write  next char
VDPDELS lda #' '                ; fill last char in line with SPACE
        sta IO_VDPRAM           ; write char
        rts
VDPDELN tfr x,d                 ; restore write address
        VDPWRITEADDRESS
        jsr VDP_Wait16c
        bra VDPDELS             ; clear last char     

VDP_ReadStatus          ; *** read status register in A - return status in A
        lda #1
        VDPSETREG 15            ; reg 15 = 1 initiates read status-reg 1
        jsr VDP_Wait16c         ; wait 8 us total for DVP
        VDPWAITC 2
        lda IO_VDPSTATUS        ; read status
        rts

**************************************************************************
; vdp-tables
VDPINITDATA                         ; ***** VDP init data table *****
        FCB $04,VDPREG1,$03,$2f,$02,$3f,$03,VDPCOLOR*16+VDPBGCOLOR
        FCB $08,VDPREG9,$00,$00,VDPBGCOLOR*16+VDPCOLOR,$f0,$00
        ; reg  0: $04 mode control 1: text mode 2 (bit#1-3 = M3 - M5)
        ; reg  1: $10 mode control 2: bit#1 16x16 sprites, bit#3-4 = M2-M1, #6 =1: display enable)
        ; reg  2: $03 name (screen) table base address $0000 ( * $400 + bit#0+1 = 1)
        ; reg  3: $2f color table base address $0A00 ( * $40 + bit#0-2 = 1)
        ; reg  4: $02 pattern (character) generator table base address $1000 (* $800)
        ; reg  5: $3f sprite attribute table base address $1e00 (* $80 - bit#0+1 = 1)
        ; reg  6: $03 sprite pattern (data) generator base address = $1800 (* $800)
        ; reg  7: $10 text/overscan-backdrop color 
        ; reg  8: $08 bit#3 = 1: 64k VRAM chips, bit#1 = 0 sprites disable, bit#5 0=transparent
        ; reg  9: $80 bit#1 = NTSC/PAL, #2 = EVEN/ODD, #3 = interlace, #7 = 192/212 lines
        ; reg 10: $00 color table base address $0000 bit#0-2 = A14-A16
        ; reg 11: $00 sprite attribute table base address bit#0-1 = A15-A16
        ; reg 12: $20 text/background blink color
        ; reg 13: $f0 blink periods ON/OFF - f0 = blinking off
        ; reg 14: $00 VRAM write addresss bit#0-2 = A14-A16
        ; reg 16: $00 color palette pointer to color 0
VDPINITDATAEND

VDPPALETTEDATA ; ***** Color Palette - 16 colors, 2 byte/color RB, 0G each 3bit -> CGA-colors *****
        FCB $00,$00,$05,$00,$00,$05,$05,$05 ;   0=black     1=blue      2=green       3=cyan
        FCB $50,$00,$55,$00,$50,$03,$55,$05 ;   4=red       5=magenta   6=brown       7=lightgrey
        FCB $33,$03,$37,$03,$33,$07,$37,$07 ;   8=grey      9=lightblue a=lightgreen  b=lightcyan
        FCB $73,$03,$77,$03,$73,$07,$77,$07 ;   c=lightred  d=ltmagenta e=yellow      f=white
VDPPALETTEDATAEND
        FCB 0                   ; only to get last label !
**************************************************************************