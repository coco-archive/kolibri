; ***** V9958 subroutines *****

PAL = 1			; PAL=1, NTSC=0	selects V9938/58 PAL RGB-output, NTSC has a higher picture

VDPRAM		= $FE28
VDPSTATUS	= $FE29	; read access
VDPCONTROL	= $FE29	; write access
VDPPALETTE	= $FE2A	; write access
VDPINDIRECT	= $FE2B	; write access

COLREG1		= $f1		; color / background+backdrop color
COLREG2		= $1f		; blink (reverse) color / background+backdrop color
VDPREG9		= $80 | PAL*2	; VDP reg 9 value ($80 = NTSC, $82 = PAL / 212 lines)
VDPREG18		= $0d		; VDP reg 18 value (V/H screen adjust, $0d = Sony PVM 9")

WAIT		MACRO ARG	; wait ARG us
		FILL ARG*3 ($12)		; each $12=nop needs 1/3 us @ 3MHz 6309/native mode
		ENDM

VDPSETREG  	MACRO ARG	; *** set VDP Register ARG to A
		sta VDPCONTROL		; first writes data in A to control port #1
		nop			; adds 2 nops to reach 2us pause
		nop
		lda # ARG | $80		; writes register no. with bit#7 = 1 to Port #1
		sta VDPCONTROL
		ENDM

VDPWRITEADDRESS 	MACRO		; *** set VDP write vram address-pointer to D
		stb VDPCONTROL		; write address low-byte
		nop			; adds 2 nops to reach 2us pause  
		nop
		ora # $40		; bit#6 = 1 write
		sta VDPCONTROL		; write address high-byte
		ENDM

**************************************************************************
VDPINIT:				; *** initialize VDP ***
		clra
		VDPSETREG 17		; write VDP regs fast indirect
		WAIT 6			; add 6 us to reach 8 us
		ldx #VDPINITDATA
VDPINITREGS	lda ,x+
		sta VDPINDIRECT
		WAIT 5			; add 5 us to reach 8us
		cmpx #VDPINITDATAEND
		bne VDPINITREGS

		lda # VDPREG18
		VDPSETREG 18		; set register 18 V/H display adjust L 7-1,0,f-8 R
					; * clear 16kB VRAM
		clrd
		WAIT 7 
		VDPWRITEADDRESS		; set VRAM write address to D = $0000, Bank Reg already $00
		ldw #$4000		; set counter W to $4000
CLEARVRAM	WAIT 6			; vdp pause between VRAM write 8 us 
		stb VDPRAM		; B = VRAM init value = $00
		decw
		bne CLEARVRAM
					; * load color palette
		clra
		WAIT 6
		VDPSETREG 16		 
		WAIT 6
		ldx #VDPPALETTEDATA
VDPINITPALETTE	lda ,x+			; load palette-color to write
		sta VDPPALETTE		; write to palette register
		WAIT 5			; add 5 us to reach 8us
		cmpx #VDPPALETTEDATAEND
		bne VDPINITPALETTE

		rts

**************************************************************************
; vdp-tables
VDPINITDATA			; ***** VDP init data table *****
	FCB $04,$50,$03,$2f,$02,$3f,$03,COLREG1,$08,VDPREG9,$00,$00,COLREG2,$f0,$00
	; reg  0: $04 mode control 1: text mode 2 (bit#1-3 = M3 - M5)
	; reg  1: $50 mode control 2: bit#1 16x16 sprites, bit#3-4 = M2-M1, #6 =1: display enable)
	; reg  2: $03 name (screen) table base address $0000 ( * $400 + bit#0+1 = 1)
	; reg  3: $2f color table base address $0A00 ( * $40 + bit#0-2 = 1)
	; reg  4: $02 pattern (character) generator table base address $1000 (* $800)
	; reg  5: $3f sprite attribute table base address $1e00 (* $80 - bit#0+1 = 1)
	; reg  6: $03 sprite pattern (data) generator base address = $1800 (* $800)
	; reg  7: $10 text/overscan-backdrop color 
	; reg  8: $08 bit#3 = 1: 64k VRAM chips, bit#1 = 0 sprites disable, bit#5 0=transparent
	; reg  9: $80 bit#1 = NTSC/PAL, #2 = EVEN/ODD, #3 = interlace, #7 = 192/212 lines
	; reg 10: $00 color table base address $0000 bit#0-2 = A14-A16
	; reg 11: $00 sprite attribute table base address bit#0-1 = A15-A16
	; reg 12: $20 text/background blink color
	; reg 13: $f0 blink periods ON/OFF - f0 = blinking off
	; reg 14: $00 VRAM write addresss bit#0-2 = A14-A16
	; reg 16: $00 color palette pointer to color 0
VDPINITDATAEND

; ***** Color Palette - 16 colors, 2 byte/color RB, 0G each 3bit -> CGA-colors *****
VDPPALETTEDATA
	FCB $00,$00,$05,$00,$00,$05,$05,$05   ;   0=black     1=blue      2=green       3=cyan
	FCB $50,$00,$55,$00,$50,$03,$55,$05   ;   4=red       5=magenta   6=brown       7=lightgrey
	FCB $33,$03,$37,$03,$33,$07,$37,$07   ;   8=grey      9=lightblue a=lightgreen  b=lightcyan
	FCB $73,$03,$77,$03,$73,$07,$77,$07   ;   c=lightred  d=ltmagenta e=yellow      f=white
VDPPALETTEDATAEND
