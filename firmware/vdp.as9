; ***** First 6309 Test with Kolibri *****

; ToDo: delete line, insert line

; VDP_Init                ; *** initialize VDP ***
; VDP_On                  ; *** enable screen ***
; VDP_Off                 ; *** disable screen ***
; VDP_SetWindow           ; *** set window to E=TopRow, F=BottomRow
; VDP_ClearWindow         ; *** clear window and color table to color 1
; VDP_BGColor1            ; *** set background-color 1 from A
; VDP_Color1              ; *** set text-color 1 from A
; VDP_BGColor2            ; *** set background-color 2from A
; VDP_Color2              ; *** set text-color 2 from A
; VDP_ReadChar            ; *** return char at actual cursor position in A
; VDP_ReadLine            ; *** store line A in LINEBUF
; VDP_PutChar             ; *** puts char from A to screen at actual cursor position and moves cursor
; VDP_PutS                ; *** puts zero terminated string from X to screen at actual cursor position
; VDP_PutColor1           ; *** set color 1 to actual cursor position (E/F untouched)
; VDP_PutColor2           ; *** set color 2 to actual cursor position (E/F untouched)
; VDP_SetChar             ; *** set char from A to screen at E=X and F=Y (E/F untouched - no scroll)
; VDP_SetColor1           ; *** set color 1 to screen at E=X and F=Y (E/F untouched)
; VDP_SetColor2           ; *** set color 2 to screen at E=X and F=Y (E/F untouched)
; VDP_CursorRight         ; *** Move cursor right
; VDP_CursorLeft          ; *** Move cursor left
; VDP_CursorDown          ; *** Move cursor down
; VDP_CursorUp            ; *** Move cursor up
; VDP_ScrollUp            ; *** scroll screen up E=TopRow, F=BottomRow
; VDP_ScrollDown          ; *** scroll screen down E=TopRow, F=BottomRow
; VDP_SetCursor           ; *** set cursor to E=X, F=Y (E/F untouched)
; VDP_GetCursor           ; *** get cursor to E=X, F=Y (E/F untouched)
; VDP_SetCursorHeigh      ; *** set cursor heigh to A lines
; VDP_CursorOff           ; *** set cursor attribute byte in color table
; VDP_CursorOn            ; *** set cursor attribute bit in color table
; VDP_CR                  ; *** carriage return - moves cursor to column 0
; VDP_LF                  ; *** line feed - cursor down + CR
; VDP_TAB                 ; *** moves cursor to next tab (columns AND $f8 = 0)
; VDP_Backspace           ; *** backspace
; VDP_Delete              ; *** delete character
; VDP_Insert              ; *** insert SPACE
; VDP_DeleteRow           ; *** delete row (only in window) at cursor position
; VDP_InsertRow           ; *** insert row (only in window) at cursor position
; VDP_ReadStatus          ; *** read status register in A - return status in A

; ***** VDP-Definitions

PAL = 1                         ; PAL=1, NTSC=0   selects V9938/58 PAL RGB-output

PATTERNTABLE    = $1000         ; font memory in VRAM
COLORTABLE      = $0A00         ; color/attribute-table in VRAM
SCREENTABLE     = $0000         ; screen memory in VRAM

VDPREG1         = $10           ; VDP reg 1 value (mode bits M1+M2, screen disabled)
VDPREG9         = $80 | PAL*2   ; VDP reg 9 value ($80 = NTSC, $82 = PAL / 212 lines)
VDPREG18        = $0D           ; VDP reg 18 value (V/H screen adjust, $0d = Sony PVM 9")

VDPCOLOR1       = 15            ; start color 1 values
VDPBGCOLOR1     = 1
VDPCOLOR2       = 12            ; start color 2 values
VDPBGCOLOR2     = 8

COLUMNS         = 80            ; screen columns
CTCOLUMNS       = COLUMNS/8     ; colortable columns
ROWS            = 26            ; used lines
CURSORCHAR      = $FF           ; character code for cursor
CURSORHEIGH     = 8             ; cursor height lines

**************************************************************************
; VDP-Macros

VDPWAITC MACRO ARG      ; *** wait ARG cycles
        FILL ARG ($12)          ; each $12=nop needs 1/3 us @ 3MHz 6309/native mode
        ENDM

ADDD8   MACRO ARG       ; *** adds 8bit value/memory to D
        addb ARG                ; add low-byte
        adca #$00               ; add carry to high-byte
        ENDM

SUBD8   MACRO ARG       ; *** sub 8bit value/memory to D
        subb ARG                ; sub low-byte
        sbca #$00               ; sub carry from high-byte
        ENDM

VDPSETREG MACRO ARG     ; *** set VDP Register ARG to A
        pshs cc                 ; safe flags
        orcc  #IRQFLAG|FIRQFLAG ; disable interrupts
        sta IO_VDPCONTROL       ; first writes data in A to control port #1
        nop                     ; adds 2 nops to reach 2us pause
        nop
        lda # ARG | $80         ; writes register no. with bit#7 = 1 to Port #1
        sta IO_VDPCONTROL
        puls cc                 ; restore flags
        ENDM

VDPWRITEADDRESS MACRO   ; *** set VDP write vram address-pointer to D
        pshs cc                 ; safe flags
        orcc #IRQFLAG|FIRQFLAG  ; disable interrupts
        stb IO_VDPCONTROL       ; write address low-byte
        nop                     ; adds 2 nops to reach 2us pause
        nop
        ora # $40               ; bit#6 = 1 write
        sta IO_VDPCONTROL       ; write address high-byte
        puls cc                 ; restore flags
        ENDM

VDPREADADDRESS MACRO    ; *** set VDP read vram address-pointer to D
        pshs cc                 ; safe flags
        orcc #IRQFLAG|FIRQFLAG  ; disable interrupts
        stb IO_VDPCONTROL       ; read address low-byte
        nop                     ; adds 2 nops to reach 2us pause
        nop
        nop
        nop
        sta IO_VDPCONTROL       ; read address high-byte
        puls cc                 ; restore flags
        ENDM

; ***** VDP-Subroutines

VDP_Wait11c             ; *** wait 11 cycles (jsr=7c, rts=4c)
        rts

VDP_Init                ; *** initialize VDP ***
        clra
        VDPSETREG 17            ; write VDP regs fast indirect
        ldx #VDPINITDATA
VDPINIT lda ,x+
        jsr VDP_Wait11c         ; loop-write=13c + 11c wait
        sta IO_VDPINDIRECT
        cmpx #VDPINITDATAEND
        bne VDPINIT

        jsr VDP_Wait11c
        lda #VDPREG18
        VDPSETREG 18            ; set register 18 V/H display adjust L 7-1,0,f-8 R
                                ; * clear 16kB VRAM
        jsr VDP_Wait11c
        clrd
        VDPWRITEADDRESS         ; set VRAM write address to D = $0000, Bank Reg already $00
        ldw #$4000              ; set counter W to $4000
VDPCLRR jsr VDP_Wait11c         ; loop-write=8c + 11c wait - >5us is OK
        stb IO_VDPRAM           ; B = VRAM init value = $00
        decw
        bne VDPCLRR
        jsr VDP_Wait11c
        clra
        VDPSETREG 14            ; set VRAM bank reg back to 0
                                ; * copy font to pattern generator table
        jsr VDP_Wait11c
        ldd #PATTERNTABLE
        VDPWRITEADDRESS         ; set VRAM write address to D = Patterntable
        ldx #VDPFONTDATA
VDPLFNT lda ,x+
        jsr VDP_Wait11c         ; loop-write=13c + 11c wait
        sta IO_VDPRAM
        cmpx #VDPFONTDATA+VDPFONTSIZE
        bne VDPLFNT
                                ; * load color palette
        jsr VDP_Wait11c
        clra
        VDPSETREG 16
        ldx #VDPPALETTEDATA
VDPLPAL lda ,x+                 ; load palette-color to write
        jsr VDP_Wait11c         ; loop-write=13c + 11c wait
        sta IO_VDPPALETTE       ; write to palette register
        cmpx #VDPPALETTEDATAEND
        bne VDPLPAL

        jsr VDP_Wait11c
        ldd #SCREENTABLE
        VDPWRITEADDRESS         ; set VRAM write address to D = Screentable
        ldw #(ROWS+1)*COLUMNS
        lda #' '                ; fill with SPACE
        sta BIOS_CursorChar     ; safe first Char under Cursor
VDPCLRS jsr VDP_Wait11c         ; loop-write=8c + 11c wait
        VDPWAITC 5              ; add. 5c for 8us
        sta IO_VDPRAM
        decw
        bne VDPCLRS

        lda #0
        sta BIOS_CursorX        ; initialize zeropage variables
        sta BIOS_CursorY
        sta BIOS_RowTop
        lda #ROWS-1
        sta BIOS_RowBottom
        lda #VDPCOLOR1
        sta BIOS_Color1
        lda #VDPBGCOLOR1
        sta BIOS_BGColor1
        lda #VDPCOLOR2
        sta BIOS_Color2
        lda #VDPBGCOLOR2
        sta BIOS_BGColor2
        lda #CURSORHEIGH
        sta BIOS_CursorHeigh
        rts

VDP_On                  ; *** enable screen ***
        lda #VDPREG1 | $40      ; set mode reg 1 (M1+M2), bit#6 = 1 enables screen
        VDPSETREG 1
        rts

VDP_Off                 ; *** disable screen ***
        lda #VDPREG1 & $bf      ; set mode reg 1 (M1+M2), bit#6 = 1 enables screen
        VDPSETREG 1
        rts

VDP_SetWindow           ; *** set window to E=TopRow, F=BottomRow
        ste BIOS_RowTop
        stf BIOS_RowBottom
        rts

VDP_ClearWindow         ; *** clear window and color table to color 1
        jsr VDP_CursorOff
        lda BIOS_RowTop         ; load windows top row
        ldb #COLUMNS            ; load columns
        mul                     ; calc screen position
        tfr d,x                 ; safe screen position in X
        addd #SCREENTABLE       ; add VRAM position
        VDPWRITEADDRESS         ; set VRAM write address to D = Screentable
        lda BIOS_RowBottom      ; load window bottom row
        adda #1                 ; add one line to bottom
        suba BIOS_RowTop        ; calc lines to clear (Carry flag already 0 from adda)
        pshs a                  ; safe lines to clear in A
        ldb #COLUMNS
        mul                     ; calc bytes to clear
        lde #' '                ; fill with SPACE
VDPCLRW jsr VDP_Wait11c
        VDPWAITC 4              ; add 4c to get 8us
        ste IO_VDPRAM
        decd
        bne VDPCLRW
        tfr x,d                 ; restore screen position
        lsrd                    ; divide position by 8
        lsrd
        lsrd
        addd #COLORTABLE        ; add colortable address
        VDPWRITEADDRESS         ; set VRAM write address
        puls a                  ; restore lines from A
        ldb #CTCOLUMNS          ; load Colortable columns
        mul                     ; calc bytes to clear
        lde #0                  ; fill with SPACE
VDPCLRC jsr VDP_Wait11c
        VDPWAITC 4              ; add 4c to get 8us
        ste IO_VDPRAM
        decd
        bne VDPCLRC
        sta BIOS_CursorX        ; set cursor to column 0 (A is already 0 from decd)
        lda BIOS_RowTop
        sta BIOS_CursorY        ; set cursor to window top line
        jsr VDP_CursorOn
        rts

VDP_BGColor1         ; *** set background-color 1 from A to register 7
        sta BIOS_BGColor1
        lda BIOS_Color1
        bra VDPCOL1

VDP_Color1           ; *** set text-color 1 from A to register 7
        sta BIOS_Color1         ; store new textcolor
VDPCOL1 lsla                    ; shift to high nibble
        lsla
        lsla
        lsla
        ora BIOS_BGColor1       ; add bg color variable
        VDPSETREG 7             ; set color register
        rts

VDP_BGColor2         ; *** set background-color 2 from A to register 12
        sta BIOS_BGColor2
        lda BIOS_Color2
        bra VDPCOL2

VDP_Color2           ; *** set text-color 2 from A to register 12
        sta BIOS_Color2         ; store new textcolor
VDPCOL2 lsla                    ; shift to high nibble
        lsla
        lsla
        lsla
        ora BIOS_BGColor2       ; add bg color variable
        VDPSETREG 12            ; set color 2 register
        rts

VDP_ReadChar            ; *** return at actual cursor position in A
        lda BIOS_CursorY        ; load cursor line
        ldb #COLUMNS            ; load columns
        mul                     ; calc line position
        ADDD8 BIOS_CursorX      ; add Cursor column to D
        addd #SCREENTABLE       ; add VRAM position
        VDPREADADDRESS          ; set VRAM read address to D = Screentable
        jsr VDP_Wait11c
        VDPWAITC 6              ; add 6c to get 8us
        lda IO_VDPRAM
        rts

VDP_ReadLine            ; *** store line A in LINEBUF
        ldb #COLUMNS            ; load columns
        mul                     ; calc line position
        addd #SCREENTABLE       ; add VRAM position
        VDPREADADDRESS          ; set VRAM read address to D = Screentable
        ldy #LINEBUF            ; load buffer address in Y
        ldb #COLUMNS            ; load columns in x-counter
VDPREAD jsr VDP_Wait11c
        VDPWAITC 2              ; 11c + 11c +2c = 8us
        lda IO_VDPRAM           ; read char
        sta ,y+                 ; write to buffer
        decb                    ; dec x-counter
        bne VDPREAD             ; read next char
        rts

VDP_DeleteRow           ; *** delete row (only in window) at cursor position
        lde BIOS_CursorY        ; scroll up to actual line
        cmpe BIOS_RowTop
        bcs VDPDRWS             ; Y above top row
        cmpe BIOS_RowBottom
        bhi VDPDRWS             ; Y below bottom row
        ldf BIOS_RowBottom      ; scroll up from bottom row
        jsr VDP_ScrollUp
VDPDRWS rts

VDP_InsertRow           ; *** insert row (only in window) at cursor position
        lde BIOS_CursorY        ; scroll down to actual line
        cmpe BIOS_RowTop
        bcs VDPIRWS             ; Y above top row
        cmpe BIOS_RowBottom
        bhi VDPIRWS             ; Y below bottom row
        ldf BIOS_RowBottom      ; scroll up from bottom row
        jsr VDP_ScrollDown
VDPIRWS rts


VDP_ScrollUp            ; *** scroll screen up E=TopRow, F=BottomRow
        tfr e,a                 ; copy top row to A for calc
        pshs a                  ; save top row on stack
        cmpr f,e                ; check lines to scroll?
        beq VDPSCRN             ; skip scrolling if only one line to scroll
        ldb #COLUMNS
        mul                     ; calc line position
        addd #SCREENTABLE       ; calc target line screen address
        tfr d,x                 ; copy target address to X
VDPSCRL ADDD8 #COLUMNS          ; add columns for source address
        VDPREADADDRESS
        ldy #LINEBUF            ; load buffer address in Y
        ldb #COLUMNS            ; load columns in x-counter
VDPSCRS jsr VDP_Wait11c
        VDPWAITC 2              ; 11c + 11c +2c = 8us
        lda IO_VDPRAM           ; load from VRAM
        sta ,y+                 ; write to buffer
        decb
        bne VDPSCRS             ; end of line?
        tfr x,d                 ; move stored target address to D
        VDPWRITEADDRESS
        ldy #LINEBUF            ; load buffer address in Y
        ldb #COLUMNS            ; load columns in x-counter
VDPSCRT jsr VDP_Wait11c
        VDPWAITC 2              ; 11c + 11c +2c = 8us
        lda ,y+
        sta IO_VDPRAM
        decb
        bne VDPSCRT
        ince                    ; next row
        cmpr f,e
        beq VDPSCRN             ; last row - finished scrolling
        tfr x,d                 ; copy last target address to D
        ADDD8 #COLUMNS          ; add columns
        tfr d,x                 ; copy next traget address to X
        bra VDPSCRL             ; scroll netxt line
VDPSCRN tfr f,a                 ; bottom row löschen
        ldb #COLUMNS
        mul
        addd #SCREENTABLE       ; calc screen address
        VDPWRITEADDRESS
        ldb #COLUMNS            ; load columns in x-counter
        lda #' '                ; clear line with SPACE
VDPSCRC jsr VDP_Wait11c
        VDPWAITC 6              ; 7c + 11c +6c = 8us
        sta IO_VDPRAM
        decb
        bne VDPSCRC
                              ; scroll colortable
        puls a                  ; restore top row to A
        tfr a,e                 ; move top row as line counter to E
        cmpr f,e                ; check lines to scroll?
        beq VDPSCAN             ; skip scrolling if only one line to scroll
        ldb #CTCOLUMNS          ; load colortable columns
        mul                     ; calc line position
        addd #COLORTABLE        ; calc target line color address
        tfr d,x                 ; copy target address to X
VDPSCAL ADDD8 #CTCOLUMNS        ; add color table columns for source address
        VDPREADADDRESS
        ldy #LINEBUF            ; load buffer address in Y
        ldb #CTCOLUMNS          ; load color table columns in x-counter
VDPSCAS jsr VDP_Wait11c
        VDPWAITC 2              ; 11c + 11c +2c = 8us
        lda IO_VDPRAM           ; load from VRAM
        sta ,y+                 ; write to buffer
        decb
        bne VDPSCAS             ; end of line?
        tfr x,d                 ; move stored target address to D
        VDPWRITEADDRESS
        ldy #LINEBUF            ; load buffer address in Y
        ldb #CTCOLUMNS          ; load columns in x-counter
VDPSCAT jsr VDP_Wait11c
        VDPWAITC 2              ; 11c + 11c +2c = 8us
        lda ,y+
        sta IO_VDPRAM
        decb
        bne VDPSCAT
        ince                    ; next row
        cmpr f,e
        beq VDPSCAN             ; last row - finished scrolling
        tfr x,d                 ; copy last target address to D
        ADDD8 #CTCOLUMNS        ; add columns
        tfr d,x                 ; copy next traget address to X
        bra VDPSCAL             ; scroll netxt line
VDPSCAN tfr f,a                 ; bottom row löschen
        ldb #CTCOLUMNS
        mul
        addd #COLORTABLE        ; calc color-table address
        VDPWRITEADDRESS
        ldb #CTCOLUMNS          ; load columns in x-counter
        lda #0                  ; clear line to color 1
VDPSCAC jsr VDP_Wait11c
        VDPWAITC 6              ; 7c + 11c +6c = 8us
        sta IO_VDPRAM
        decb
        bne VDPSCAC
        rts

VDP_ScrollDown            ; *** scroll screen down E=TopRow, F=BottomRow
        tfr f,a                 ; copy bottom row to A for calc
        pshs a                  ; save bottom row on stack
        cmpr f,e                ; check lines to scroll?
        beq VDPSDWN             ; skip scrolling if only one line to scroll
        ldb #COLUMNS
        mul                     ; calc line position
        addd #SCREENTABLE       ; calc target line screen address
        tfr d,x                 ; copy target address to X
VDPSDWL SUBD8 #COLUMNS          ; sub columns for source address
        VDPREADADDRESS
        ldy #LINEBUF            ; load buffer address in Y
        ldb #COLUMNS            ; load columns in x-counter
VDPSDWS jsr VDP_Wait11c
        VDPWAITC 2              ; 11c + 11c +2c = 8us
        lda IO_VDPRAM           ; load from VRAM
        sta ,y+                 ; write to buffer
        decb
        bne VDPSDWS             ; end of line?
        tfr x,d                 ; move stored target address to D
        VDPWRITEADDRESS
        ldy #LINEBUF            ; load buffer address in Y
        ldb #COLUMNS            ; load columns in x-counter
VDPSDWT jsr VDP_Wait11c
        VDPWAITC 2              ; 11c + 11c +2c = 8us
        lda ,y+
        sta IO_VDPRAM
        decb
        bne VDPSDWT
        decf                    ; next row
        cmpr f,e
        beq VDPSDWN             ; last row - finished scrolling
        tfr x,d                 ; copy last target address to D
        SUBD8 #COLUMNS          ; sub columns
        tfr d,x                 ; copy next traget address to X
        bra VDPSDWL             ; scroll netxt line
VDPSDWN tfr e,a                 ; top row löschen
        ldb #COLUMNS
        mul
        addd #SCREENTABLE       ; calc screen address
        VDPWRITEADDRESS
        ldb #COLUMNS            ; load columns in x-counter
        lda #' '                ; clear line with SPACE
VDPSDWC jsr VDP_Wait11c
        VDPWAITC 6              ; 7c + 11c +6c = 8us
        sta IO_VDPRAM
        decb
        bne VDPSDWC
                              ; scroll colortable
        puls a                  ; restore bottom row to A
        tfr a,f                 ; move bottom row as line counter to F
        cmpr f,e                ; check lines to scroll?
        beq VDPSDAN             ; skip scrolling if only one line to scroll
        ldb #CTCOLUMNS          ; load colortable columns
        mul                     ; calc line position
        addd #COLORTABLE        ; calc target line color address
        tfr d,x                 ; copy target address to X
VDPSDAL SUBD8 #CTCOLUMNS        ; sub color table columns for source address
        VDPREADADDRESS
        ldy #LINEBUF            ; load buffer address in Y
        ldb #CTCOLUMNS          ; load color table columns in x-counter
VDPSDAS jsr VDP_Wait11c
        VDPWAITC 2              ; 11c + 11c +2c = 8us
        lda IO_VDPRAM           ; load from VRAM
        sta ,y+                 ; write to buffer
        decb
        bne VDPSDAS             ; end of line?
        tfr x,d                 ; move stored target address to D
        VDPWRITEADDRESS
        ldy #LINEBUF            ; load buffer address in Y
        ldb #CTCOLUMNS          ; load columns in x-counter
VDPSDAT jsr VDP_Wait11c
        VDPWAITC 2              ; 11c + 11c +2c = 8us
        lda ,y+
        sta IO_VDPRAM
        decb
        bne VDPSDAT
        decf                    ; next row
        cmpr f,e
        beq VDPSDAN             ; last row - finished scrolling
        tfr x,d                 ; copy last target address to D
        SUBD8 #CTCOLUMNS        ; sub columns
        tfr d,x                 ; copy next traget address to X
        bra VDPSDAL             ; scroll netxt line
VDPSDAN tfr e,a                 ; top row löschen
        ldb #CTCOLUMNS
        mul
        addd #COLORTABLE        ; calc color-table address
        VDPWRITEADDRESS
        ldb #CTCOLUMNS          ; load columns in x-counter
        lda #0                  ; clear line to color 1
VDPSDAC jsr VDP_Wait11c
        VDPWAITC 6              ; 7c + 11c +6c = 8us
        sta IO_VDPRAM
        decb
        bne VDPSDAC
        rts

VDP_PutColor1       ; *** set color 1 to actual cursor position (E/F untouched)
        lda BIOS_CursorY        ; load cursor line
        ldb #COLUMNS            ; load columns
        mul                     ; calc line position
        addb BIOS_CursorX       ; add cursor column to low-byte
        bra VDPSCO1

VDP_SetColor1       ; *** set color 1 to screen at E=X and F=Y (E/F untouched)
        tfr f,a                 ; load line
        ldb #COLUMNS            ; load columns
        mul                     ; calc line position
        addr e,b                ; add column to low-byte
VDPSCO1 adca #$00               ; add carry to high-byte
        pshs b                  ; safe low byte of screen position on stack
        lsrd                    ; divide by 8 to calc color/attribute-table position
        lsrd
        lsrd
        addd #COLORTABLE        ; add VRAM position
        tfr d,y                 ; safe VRAM address in Y
        VDPREADADDRESS
        puls b                  ; restore low byte
        andb #$07               ; isolate byte position
        clra
        tfr d,x                 ; store table offset in X
        lda CLEARBITTABLE,x     ; load bit-mask to clear
        anda IO_VDPRAM          ; calc new attribute-byte
        pshs a                  ; safe attribute-byte
        tfr y,d                 ; restore write address
        VDPWAITC 9
        VDPWRITEADDRESS         ; set VRAM write address
        puls a                  ; restore atribute-byte
        jsr VDP_Wait11c
        VDPWAITC 2
        sta IO_VDPRAM
        rts

VDP_PutColor2       ; *** set color 2 to actual cursor position (E/F untouched)
        lda BIOS_CursorY        ; load cursor line
        ldb #COLUMNS            ; load columns
        mul                     ; calc line position
        addb BIOS_CursorX       ; add cursor column to low-byte
        bra VDPSCO2

VDP_SetColor2       ; *** set color 2 to screen at E=X and F=Y (E/F untouched)
        tfr f,a                 ; load line
        ldb #COLUMNS            ; load columns
        mul                     ; calc line position
        addr e,b                ; add column to low-byte
VDPSCO2 adca #$00               ; add carry to high-byte
        pshs b                  ; safe low byte of screen position on stack
        lsrd                    ; divide by 8 to calc color/attribute-table position
        lsrd
        lsrd
        addd #COLORTABLE        ; add VRAM position
        tfr d,y                 ; safe VRAM address in Y
        VDPREADADDRESS
        puls b                  ; restore low byte
        andb #$07               ; isolate byte position
        clra
        tfr d,x                 ; store table offset in X
        lda SETBITTABLE,x       ; load bit-mask to set bit
        ora IO_VDPRAM           ; calc new attribute-byte
        pshs a                  ; safe attribute-byte
        tfr y,d                 ; restore write address
        VDPWAITC 9
        VDPWRITEADDRESS         ; set VRAM write address
        puls a                  ; restore atribute-byte
        jsr VDP_Wait11c
        VDPWAITC 2
        sta IO_VDPRAM
        rts

VDP_SetChar             ; *** set char from A to screen at E=X and F=Y
        pshs a                  ; safe char on stack
        tfr f,a                 ; load cursor line
        ldb #COLUMNS            ; load columns
        mul                     ; calc line position
        addr e,b                ; add cursor column to low-byte
        adca #$00               ; add carry to high-byte
        addd #SCREENTABLE       ; add VRAM position
        VDPWRITEADDRESS         ; set VRAM write address to D = Screentable
        jsr VDP_Wait11c
        VDPWAITC 2              ; add 2c to get 8us
        puls a                  ; restore char from stack
        sta IO_VDPRAM
        rts

VDP_PutChar             ; *** puts char from A to screen at actual cursor position and moves cursor
        tfr a,e                 ; safe char in E
        lda BIOS_CursorY        ; load cursor line
        ldb #COLUMNS            ; load columns
        mul                     ; calc line position
        ADDD8 BIOS_CursorX      ; add Cursor column to D
        addd #SCREENTABLE       ; add VRAM position
        VDPWRITEADDRESS         ; set VRAM write address to D = Screentable
        jsr VDP_Wait11c
        VDPWAITC 5              ; add 5c to get 8us
        ste IO_VDPRAM
        bra VDPCRSM             ; move cursor right

VDP_PutS                ; *** puts zero terminated string from X to screen at actual cursor position
        lda ,x+                 ; fetch character and increment pointer
        beq VDPPS80             ; -> zero terminator
        pshs x
        jsr  VDP_Out            ; write character to screen
        puls x
        bra VDP_PutS
VDPPS80 rts

VDP_CursorRight         ; *** move cursor right
        bsr VDP_CursorOff
VDPCRSM lda BIOS_CursorX
        inca                    ; move right
        cmpa #COLUMNS           ; end of line ?
        bne VDPCRSR             ; not column end ?
        lda BIOS_CursorY
        cmpa BIOS_RowBottom     ; reached window bottom row ?
        bne VDPCRRS             ; no scroll neccessary
        lde BIOS_RowTop         ; scroll up to top row
        ldf BIOS_RowBottom      ; scroll up from bottom row
        jsr VDP_ScrollUp
        bra VDPCRRE
VDPCRRS inca
        sta BIOS_CursorY
VDPCRRE clra
VDPCRSR sta BIOS_CursorX
        bsr VDP_CursorOn
        rts

VDP_SetCursorHeigh      ; *** set cursor heigh to A lines
        sta BIOS_CursorHeigh
        bsr VDP_CursorOff
        bsr VDP_CursorOn
        rts

VDP_CursorDown          ; *** move cursor down
        bsr VDP_CursorOff
        lda BIOS_CursorY
        cmpa BIOS_RowBottom     ; reached window bottom row ?
        bne VDPCRDD
        lde BIOS_RowTop         ; scroll up to top row
        ldf BIOS_RowBottom      ; scroll up from bottom row
        jsr VDP_ScrollUp
        bra VDPCRDS
VDPCRDD lda BIOS_CursorY
        inca
        sta BIOS_CursorY        ; move down
VDPCRDS bsr VDP_CursorOn
        rts

VDP_CursorUp            ; *** move cursor up
        bsr VDP_CursorOff
        lda BIOS_CursorY
        cmpa BIOS_RowTop        ; reached window top row ?
        beq VDPCRSU
        deca
        sta BIOS_CursorY        ; move up
VDPCRSU bsr VDP_CursorOn
        rts

VDP_SetCursor           ; *** set cursor to E=X, F=Y
        bsr VDP_CursorOff
        ste BIOS_CursorX
        stf BIOS_CursorY
        bsr VDP_CursorOn
        rts

VDP_GetCursor           ; *** get cursor to E=X, F=Y
        lde BIOS_CursorX
        ldf BIOS_CursorY
        rts

VDP_CursorOff            ; *** reset last character under cursor
        lda BIOS_CursorY        ; load cursor line
        ldb #COLUMNS            ; load columns
        mul                     ; calc line position
        ADDD8 BIOS_CursorX      ; add Cursor column to D
        addd #SCREENTABLE       ; add VRAM position
        VDPWRITEADDRESS         ; set VRAM write address to D = Screentable
        jsr VDP_Wait11c
        VDPWAITC 3              ; add 3c to get 8us
        lda BIOS_CursorChar     ; load last character under cursor
        sta IO_VDPRAM
        rts

VDP_CursorOn            ; *** set cursor at actual position
        lda BIOS_CursorY        ; load cursor line
        ldb #COLUMNS            ; load columns
        mul                     ; calc line position
        ADDD8 BIOS_CursorX      ; add Cursor column to D
        addd #SCREENTABLE       ; add VRAM position
        pshs d                  ; safe screentable position
        VDPREADADDRESS          ; set VRAM read address to D = Screentable
        jsr VDP_Wait11c
        VDPWAITC 6              ; add 6c to get 8us
        ldb IO_VDPRAM
        stb BIOS_CursorChar     ; save last character under cursor
        clra                    ; clear highbyte
        lsld                    ; calc char position in table
        lsld
        lsld
        addd #VDPFONTDATA       ; add fonttable start address
        tfr d,x                 ; move fonttable position to X
        ldd #PATTERNTABLE+(8*CURSORCHAR)    ; load patterntable position in VRAM
        VDPWRITEADDRESS         ; set VRAM write address to char in patterntable
        ldb #8                  ; char lines to copy
VDPCRSO VDPWAITC 5              ; add nops to reach 8us
        lda ,x+                 ; load char line from fonttable
        decb                    ; decrement line counter
        cmpb BIOS_CursorHeigh   ; check for cursor heigh reached
        bcc VDPCRSN             ; skip eor if not reverse line
        eora #$FF               ; reverse char line
VDPCRSN sta IO_VDPRAM           ; write char line to patterntable in VRAM
        cmpb #0                 ; last line done?
        bne VDPCRSO             ; copy next char line
        puls d                  ; restore screentable position
        VDPWRITEADDRESS         ; set VRAM write address to D = Screentable
        jsr VDP_Wait11c
        VDPWAITC 3              ; add 3c to get 8us
        lda #CURSORCHAR         ; load reserved cursor-code
        sta IO_VDPRAM
        rts

VDP_CR                  ; *** carriage return - moves cursor to column 0
        lbsr VDP_CursorOff
VDPCR   lda #0
VDPCRT  sta BIOS_CursorX
        lbsr VDP_CursorOn
        rts

VDP_LF                  ; *** line feed - cursor down + CR
        lbsr VDP_CursorOff
VDPLF   lda BIOS_CursorY
        cmpa BIOS_RowBottom     ; reached window bottom row ?
        bne VDPLFNS
        lde BIOS_RowTop         ; scroll up to top row
        ldf BIOS_RowBottom      ; scroll up from bottom row
        jsr VDP_ScrollUp
        bra VDPCR
VDPLFNS inca
        sta BIOS_CursorY        ; move down
        bra VDPCR               ; jump to CR

VDP_CursorLeft          ; *** Move cursor left
        jsr VDP_CursorOff
        lda BIOS_CursorX
        bne VDPCRSL             ; not column 0 ?
        lda BIOS_CursorY
        cmpa BIOS_RowTop        ; reached window top row ?
        beq VDPCRLE
        deca                    ; move one row up
        sta BIOS_CursorY
        lda #COLUMNS
VDPCRSL deca                    ; move left
        sta BIOS_CursorX
VDPCRLE jsr VDP_CursorOn
        rts

VDP_TAB                 ; *** moves cursor to next tab (columns AND $f8 = 0)
        jsr VDP_CursorOff
        lda BIOS_CursorX
        adda #8                 ; add 8 columns
        anda #$f8               ; clear bits 0-2 to set on tab position
        cmpa #COLUMNS           ; check if beyond line end?
        bcs VDPCRT              ; column is lower then columns
        bra VDPLF               ; jump to line feed

VDP_Backspace           ; *** backspace
        jsr VDP_CursorOff
        lda BIOS_CursorX
        bne VDPBACL             ; not column 0 ?
        lda BIOS_CursorY
        cmpa BIOS_RowTop        ; reached window top row ?
        beq VDPBACE
        deca                    ; move one row up
        sta BIOS_CursorY
        lda #COLUMNS            ; load last column+1
VDPBACL deca                    ; move left
        sta BIOS_CursorX
        bra VDP_Delete          ; delete
VDPBACE jsr VDP_CursorOn
        rts                     ; no delete possible in uper left corner !

VDPDELN VDPWRITEADDRESS
        bra VDPDELS             ; clear last char in line
VDP_Delete              ; *** delete character
        lda BIOS_CursorY        ; load cursor line
        ldb #COLUMNS            ; load columns
        mul                     ; calc line position
        ADDD8 BIOS_CursorX      ; add Cursor column to D
        addd #SCREENTABLE       ; add VRAM position
        tfr d,x                 ; safe write address in X
        lde BIOS_CursorX        ; Load Cursor column
        ince                    ; add 1 because last col is 79 and columns is 80 !
        cmpe #COLUMNS           ; check if last char in line
        beq VDPDELN             ; skip srolling
        incd                    ; calc read address
        VDPREADADDRESS          ; set VRAM read address to D = Screentable
        tfr e,b                 ; move x-counter to B
        ldy #LINEBUF            ; load buffer address in Y
VDPDELR jsr VDP_Wait11c
        lda IO_VDPRAM           ; load char
        sta ,y+                 ; write char to buffer
        incb
        cmpb #COLUMNS           ; check reached end of line ?
        bne VDPDELR             ; read next char
        tfr x,d                 ; restore write address
        VDPWRITEADDRESS
        tfr e,b                 ; move x-counter to B
        ldy #LINEBUF            ; load buffer address in Y
VDPDELW jsr VDP_Wait11c
        lda ,y+                 ; read char from buffer
        sta IO_VDPRAM           ; write char
        incb
        cmpb #COLUMNS           ; check reached end of chars in buffer ?
        bne VDPDELW             ; write  next char
VDPDELS lda #' '                ; fill last char in line with SPACE
        jsr VDP_Wait11c
        VDPWAITC 1              ; add 1c to get 8us minimum
        sta IO_VDPRAM           ; write char
                              ; delete in colortable line
        bsr VDP_ReadColorLine   ; read line from colortable
        ldb BIOS_CursorX        ; Load Cursor column
        ldx #LINEBUF            ; load buffer address in X
        abx                     ; add Cursor column for buffer write address
        leay 1,x                ; add 1 for buffer read address in Y
        cmpb #COLUMNS-1         ; check if last char in line
        beq VDPDECS             ; skip srolling
VDPDECL lda ,y+                 ; load char from buffer
        sta ,x+                 ; write char to buffer
        incb
        cmpb #COLUMNS-1         ; check reached end of line ?
        bne VDPDECL             ; read next char
VDPDECS clr LINEBUF+COLUMNS-1   ; clear last colorbit in line
        bsr VDP_WriteColorLine  ; write back line to colortable
        jsr VDP_CursorOn
        rts

VDP_ReadColorLine       ; * read colortable line
        lda BIOS_CursorY        ; load cursor line
        ldb #CTCOLUMNS          ; load colortable columns
        mul                     ; calc line position
        addd #COLORTABLE        ; add VRAM position
        pshs d                  ; safe VRAM position on stack
        VDPREADADDRESS          ; set VRAM read address to D = Colortable
        lde #CTCOLUMNS          ; set counter to colortable columns
        ldx #LINEBUF            ; set X to linebuffer
        jsr VDP_Wait11c
VDPRDBY ldf #8                  ; set bitcounter
        ldb IO_VDPRAM           ; load byte from colortable
VDPRDBI asld                    ; shift left bit from B to A
        anda #01                ; isolate bit #0
        sta ,x+                 ; write colorbit to linebuffer
        decf                    ; reduce bit counter
        bne VDPRDBI             ; next bit
        dece                    ; reduce byte counter
        bne VDPRDBY             ; next byte
        rts

VDP_WriteColorLine      ; * write colortable line
        puls d                  ; restore VRAM position
        VDPWRITEADDRESS         ; set VRAM write address to D = Colortable
        lde #CTCOLUMNS          ; set counter to colortable columns
        ldx #LINEBUF            ; set X to linebuffer
VDPWRBY ldf #8                  ; set bitcounter
VDPWRBI ldb ,x+                 ; load colorbit from linebuffer
        rorb                    ; shift colorbit in C
        rola                    ; shift colorbit from C to A
        decf                    ; reduce bit counter
        bne VDPWRBI             ; next bit
        sta IO_VDPRAM           ; write byte to colortable
        dece                    ; reduce byte counter
        bne VDPWRBY             ; next byte
        rts

VDP_Insert              ; *** insert character
        jsr VDP_CursorOff
        lda BIOS_CursorY        ; load cursor line
        ldb #COLUMNS            ; load columns
        mul                     ; calc line position
        ADDD8 BIOS_CursorX      ; add Cursor column to D
        addd #SCREENTABLE       ; add VRAM position
        tfr d,x                 ; safe read address in X
        lde BIOS_CursorX        ; Load Cursor column
        cmpe #COLUMNS-1         ; check if last char in line
        beq VDPINSN             ; skip srolling
        VDPREADADDRESS          ; set VRAM read address to D = Screentable
        tfr e,b                 ; move x-counter to B
        ldy #LINEBUF            ; load buffer address in Y
VDPINSR jsr VDP_Wait11c
        lda IO_VDPRAM           ; load char
        sta ,y+                 ; write char to buffer
        incb
        cmpb #COLUMNS-1         ; check reached end of line -1 ?
        bne VDPINSR             ; read next char
        tfr x,d                 ; restore read address
        incd                    ; add 1 to get write address
        VDPWRITEADDRESS
        tfr e,b                 ; move x-counter to B
        ldy #LINEBUF            ; load buffer address in Y
VDPINSW jsr VDP_Wait11c
        lda ,y+                 ; read char from buffer
        sta IO_VDPRAM           ; write char
        incb
        cmpb #COLUMNS-1         ; check reached end of chars in buffer ?
        bne VDPINSW             ; write  next char
        tfr x,d                 ; restore write address - cursor position
        VDPWAITC 6              ; add 6c to get 8us
VDPINSN VDPWRITEADDRESS
        lda #' '                ; fill cursor position in line with SPACE
        jsr VDP_Wait11c
        VDPWAITC 4              ; add 4c to get 8us minimum
        sta IO_VDPRAM           ; write char
                              ; insert in colortable line
        jsr VDP_ReadColorLine   ; read line from colortable
        ldb BIOS_CursorX        ; Load Cursor column
        cmpb #COLUMNS-1         ; check if last char in line
        beq VDPINSS             ; skip srolling
        ldx #LINEBUF+COLUMNS    ; load buffer end address +1 in X
        leay -1,x               ; sub 1 for buffer read address in Y
VDPINSL lda ,-y                 ; load char from buffer
        sta ,-x                 ; write char to buffer
        incb
        cmpb #COLUMNS-1         ; check reached end of line ?
        bne VDPINSL             ; read next char
VDPINSS ldb BIOS_CursorX        ; Load Cursor column
        ldx #LINEBUF            ; load buffer address in X
        abx                     ; add Cursor column for buffer write address
        clra
        sta ,x                  ; clear color under cursor
        jsr VDP_WriteColorLine  ; write back line to colortable
        jsr VDP_CursorOn
        rts

VDP_ReadStatus          ; *** read status register in A - return status in A
        lda #1
        VDPSETREG 15            ; reg 15 = 1 initiates read status-reg 1
        jsr VDP_Wait11c
        VDPWAITC 6              ; 18c+6c = wait 8 us total for VPD
        lda IO_VDPSTATUS        ; read status
        rts

**************************************************************************
; vdp-tables
SETBITTABLE    FCB $80,$40,$20,$10,$08,$04,$02,$01
CLEARBITTABLE  FCB $7F,$BF,$DF,$EF,$F7,$FB,$FD,$FE

VDPINITDATA                         ; ***** VDP init data table *****
        FCB $04,VDPREG1,$03,$2f,$02,$3f,$03,VDPCOLOR1*16+VDPBGCOLOR1
        FCB $08,VDPREG9,$00,$00,VDPCOLOR2*16+VDPBGCOLOR2,$f0,$00
        ; reg  0: $04 mode control 1: text mode 2 (bit#1-3 = M3 - M5)
        ; reg  1: $10 mode control 2: bit#1 16x16 sprites, bit#3-4 = M2-M1, #6 =1: display enable)
        ; reg  2: $03 name (screen) table base address $0000 ( * $400 + bit#0+1 = 1)
        ; reg  3: $2f color table base address $0A00 ( * $40 + bit#0-2 = 1)
        ; reg  4: $02 pattern (character) generator table base address $1000 (* $800)
        ; reg  5: $3f sprite attribute table base address $1e00 (* $80 - bit#0+1 = 1)
        ; reg  6: $03 sprite pattern (data) generator base address = $1800 (* $800)
        ; reg  7: $10 text/overscan-backdrop color
        ; reg  8: $08 bit#3 = 1: 64k VRAM chips, bit#1 = 0 sprites disable, bit#5 0=transparent
        ; reg  9: $80 bit#1 = NTSC/PAL, #2 = EVEN/ODD, #3 = interlace, #7 = 192/212 lines
        ; reg 10: $00 color table base address $0000 bit#0-2 = A14-A16
        ; reg 11: $00 sprite attribute table base address bit#0-1 = A15-A16
        ; reg 12: $20 text/background blink color
        ; reg 13: $f0 blink periods ON/OFF - f0 = blinking off
        ; reg 14: $00 VRAM write addresss bit#0-2 = A14-A16
        ; reg 16: $00 color palette pointer to color 0
VDPINITDATAEND

VDPPALETTEDATA ; ***** Color Palette - 16 colors, 2 byte/color RB, 0G each 3bit -> CGA-colors *****
        FCB $00,$00,$05,$00,$00,$05,$05,$05 ;   0=black     1=blue      2=green       3=cyan
        FCB $50,$00,$55,$00,$50,$03,$55,$05 ;   4=red       5=magenta   6=brown       7=lightgrey
        FCB $33,$03,$37,$03,$33,$07,$37,$07 ;   8=grey      9=lightblue a=lightgreen  b=lightcyan
        FCB $73,$03,$77,$03,$73,$07,$77,$07 ;   c=lightred  d=ltmagenta e=yellow      f=white
VDPPALETTEDATAEND

*********
VDP_TABLE
*********

        FDB VDP_Delete      ;NUL      = $00 ; Ctrl @  DEL
        FDB VDP_Color2      ;SOH      = $01 ; Ctrl A  Foreground Color 2
        FDB VDP_BGColor2    ;STX      = $02 ; Ctrl B  Background Color 2
        FDB VDP_Ignore      ;BREAK    = $03 ; Ctrl C
        FDB VDP_CursorRight ;CUR_RIG  = $04 ; Ctrl D  Cursor Right     (WS)
        FDB VDP_CursorUp    ;CUR_UP   = $05 ; Ctrl E  Cursor Up        (WS)
        FDB VDP_Ignore      ;ERA_EOL  = $06 ; CTRL F  Erase To EOL
        FDB VDP_Ignore      ;BEL      = $07 ; Ctrl G  Bell             (ASCII)
        FDB VDP_Backspace   ;BS       = $08 ; Ctrl H  Backspace        (ASCII)
        FDB VDP_TAB         ;HT       = $09 ; Ctrl I  Tab              (ASCII)
        FDB VDP_LF          ;LF       = $0A ; Ctrl J  Line Feed        (ASCII)
        FDB VDP_ClearWindow ;CLEAR    = $0B ; Ctrl K  Window Clear
        FDB VDP_Ignore      ;HOME     = $0C ; Ctrl L  Window Home
        FDB VDP_CR          ;CR       = $0D ; Ctrl M  Return           (ASCII)
        FDB VDP_InsertRow   ;INS_ROW  = $0E ; Ctrl N  Insert Row       (WS)
        FDB VDP_Insert      ;INS_SPA  = $0F ; Ctrl O  Insert Space
        FDB VDP_SetWindow   ;SET_WIN  = $10 ; Ctrl P  Set Window
        FDB VDP_Ignore      ;         = $11 ; Ctrl Q
        FDB VDP_SetCursor   ;SET_CUR  = $12 ; Ctrl R  Set Cursor
        FDB VDP_CursorLeft  ;CUR_LEF  = $13 ; Ctrl S  Cursor Left      (WS)
        FDB VDP_Ignore      ;TOG_STA  = $14 ; Ctrl T  Toggle Status Row
        FDB VDP_Ignore      ;REVERSE  = $15 ; Ctrl U  Reverse FG/BG
        FDB VDP_Ignore      ;TOG_INS  = $16 ; Ctrl V  Toggle Insert    (WS)
        FDB VDP_ScrollDown  ;SCR_DWN  = $17 ; Ctrl W  Scroll Down      (WS)
        FDB VDP_CursorDown  ;CUR_DWN  = $18 ; Ctrl X  Cursor Down      (WS)
        FDB VDP_DeleteRow   ;DEL_ROW  = $19 ; Ctrl Y  Delete Row       (WS)
        FDB VDP_ScrollUp    ;SCR_UP   = $1A ; Ctrl-Z  Scroll Up        (WS)
        FDB VDP_Ignore      ;ESC      = $1B ; ESCAPE                   (ASCII)
        FDB VDP_Color1      ;FS       = $1C ;         Foreground Color
        FDB VDP_BGColor1    ;GS       = $1D ;         Background Color
        FDB VDP_CursorOn    ;RS       = $1E ;         Show Cursor
        FDB VDP_CursorOff   ;US       = $1F ;         Hide Cursor

**********
VDP_Ignore
**********
        RTS

        FCB 0                   ; only to get last label !
**************************************************************************
